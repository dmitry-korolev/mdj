{"version":3,"file":"index.js","sources":["../src/utils/curry.ts","../src/utils/clearSource.ts","../src/utils/compose.ts","../src/utils/exec.ts","../src/utils/equals.ts","../src/utils/map.ts","../src/utils/match.ts","../src/utils/matches.ts","../src/utils/replace.ts","../src/utils/split.ts","../src/utils/trim.ts","../src/utils/startsWith.ts","../src/blockParsers/captureBlockquote.ts","../src/blockParsers/code/captureCodeBlock.ts","../src/blockParsers/headings/captureHeading.ts","../src/blockParsers/captureHR.ts","../src/blockParsers/html/captureHTML.ts","../src/blockParsers/captureList.ts","../src/blockParsers/captureNewLine.ts","../src/blockParsers/captureParagraph.ts","../src/blockParsers/tables/captureTable.ts","../src/inlineParsers/captureCode.ts","../src/inlineParsers/captureEm.ts","../src/inlineParsers/captureEscape.ts","../src/inlineParsers/html/captureInlineHTML.ts","../src/inlineParsers/captureLinebreak.ts","../src/inlineParsers/links/captureLinks.ts","../src/inlineParsers/captureStrikethrough.ts","../src/inlineParsers/captureStrong.ts","../src/inlineParsers/captureText.ts","../src/core/MDJ.ts","../src/index.ts"],"sourcesContent":["/* tslint:disable: only-arrow-functions max-line-length */\n// Yep, interfaces are stolen from ramda types\ninterface ICurriedFunction2<T1, T2, R> {\n  (t1: T1): (t2: T2) => R\n  (t1: T1, t2: T2): R\n}\n\ninterface ICurriedFunction3<T1, T2, T3, R> {\n  (t1: T1): ICurriedFunction2<T2, T3, R>\n  (t1: T1, t2: T2): (t3: T3) => R\n  (t1: T1, t2: T2, t3: T3): R\n}\n\ninterface ICurriedFunction4<T1, T2, T3, T4, R> {\n  (t1: T1): ICurriedFunction3<T2, T3, T4, R>\n  (t1: T1, t2: T2): ICurriedFunction2<T3, T4, R>\n  (t1: T1, t2: T2, t3: T3): (t4: T4) => R\n  (t1: T1, t2: T2, t3: T3, t4: T4): R\n}\n\ninterface ICurriedFunction5<T1, T2, T3, T4, T5, R> {\n  (t1: T1): ICurriedFunction4<T2, T3, T4, T5, R>\n  (t1: T1, t2: T2): ICurriedFunction3<T3, T4, T5, R>\n  (t1: T1, t2: T2, t3: T3): ICurriedFunction2<T4, T5, R>\n  (t1: T1, t2: T2, t3: T3, t4: T4): (t5: T5) => R\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R\n}\n\ninterface ICurriedFunction6<T1, T2, T3, T4, T5, T6, R> {\n  (t1: T1): ICurriedFunction5<T2, T3, T4, T5, T6, R>\n  (t1: T1, t2: T2): ICurriedFunction4<T3, T4, T5, T6, R>\n  (t1: T1, t2: T2, t3: T3): ICurriedFunction3<T4, T5, T6, R>\n  (t1: T1, t2: T2, t3: T3, t4: T4): ICurriedFunction2<T5, T6, R>\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): (t6: T6) => R\n  (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): R\n}\n\ninterface ICurry {\n  <T1, T2, TResult>(fn: (a: T1, b: T2) => TResult, args?: any): ICurriedFunction2<T1, T2, TResult>\n  <T1, T2, T3, TResult>(fn: (a: T1, b: T2, c: T3) => TResult, args?: any): ICurriedFunction3<T1, T2, T3, TResult>\n  <T1, T2, T3, T4, TResult>(fn: (a: T1, b: T2, c: T3, d: T4) => TResult, args?: any): ICurriedFunction4<T1, T2, T3, T4, TResult>\n  <T1, T2, T3, T4, T5, TResult>(fn: (a: T1, b: T2, c: T3, d: T4, e: T5) => TResult, args?: any): ICurriedFunction5<T1, T2, T3, T4, T5, TResult>\n  <T1, T2, T3, T4, T5, T6, TResult>(fn: (a: T1, b: T2, c: T3, d: T4, e: T5, f: T6) => TResult, args?: any): ICurriedFunction6<T1, T2, T3, T4, T5, T6, TResult>\n}\n\nconst curry: ICurry = function () {\n  const fn: (...args: any[]) => any = arguments[0]\n  const length = fn.length\n\n  const inner = function () {\n    const args = Array.prototype.slice.call(arguments)\n\n    if (args.length >= length) {\n      return fn.apply(null, args)\n    } else {\n      return inner.bind.apply(inner, [null].concat(args))\n    }\n  }\n\n  return inner.bind.apply(inner, [null].concat(Array.prototype.slice.call(arguments, 1)))\n}\n\nexport { curry }\n","const clearSource = (input: string) => input.replace(/\\r\\n|\\r/g, '\\n')\n  .replace(/\\t/g, '    ')\n  .replace(/\\u00a0/g, ' ')\n  .replace(/\\u2424/g, '\\n')\n  .replace(/^ +$/gm, '')\n\nexport { clearSource }\n","/* tslint:disable: only-arrow-functions max-line-length */\n\ninterface ICompose {\n  <V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1\n  <V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1\n  <V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1\n\n  <V0, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0) => T1): (x0: V0) => T2\n  <V0, V1, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T2\n  <V0, V1, V2, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T2\n\n  <V0, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T3\n  <V0, V1, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T3\n  <V0, V1, V2, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T3\n\n  <V0, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T4\n  <V0, V1, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T4\n  <V0, V1, V2, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T4\n\n  <V0, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T5\n  <V0, V1, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T5\n  <V0, V1, V2, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T5\n\n  <V0, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T6\n  <V0, V1, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T6\n  <V0, V1, V2, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T6\n}\n\nconst compose: ICompose = function () {\n  const fns = Array.prototype.slice.call(arguments)\n  const l = fns.length - 1\n\n  return function (arg: any) {\n    let result = arg\n\n    for (let i = l; i >= 0; i -= 1) {\n      result = fns[i](result)\n    }\n\n    return result\n  }\n}\n\nexport { compose }\n","import { curry } from 'utils'\n\nconst exec = curry((regExp: RegExp, input: string): string[] | null => regExp.exec(input))\n\nexport { exec }\n","import { curry } from 'utils'\n\nconst equals = curry((a: any, b: any): boolean => a === b)\n\nexport { equals }\n","import { curry } from 'utils'\n\ninterface IMap {\n  <V, R>(fn: (x0: V, x1: number, x2: V[]) => R): (input: V[]) => R[]\n  <V, R>(fn: (x0: V, x1: number, x2: V[]) => R, input: V[]): R[]\n}\n\nconst map: IMap = curry(<V, R>(fn: (x0: V, x1: number, x2: V[]) => R , input: V[]) => {\n  const result = new Array(input.length)\n\n  for (let i = 0; i < input.length; i += 1) {\n    result[i] = fn(input[i], i, input)\n  }\n\n  return result\n})\n\nexport { map }\n","import { curry } from 'utils'\n\nconst match = curry((regExp: RegExp, input: string) => input.match(regExp) || [])\n\nexport { match }\n","import { curry } from 'utils'\n\nconst matches = curry((withWhat: RegExp, what: string) => withWhat.test(what))\n\nexport { matches }\n","import { curry } from 'utils'\n\nconst replace = curry((from: string | RegExp, to: string, input: string) => input.replace(from, to))\n\nexport { replace }\n","import { curry } from 'utils'\n\nconst split = curry((regExp: RegExp | string, input: string): string[] => input.split(regExp))\n\nexport { split }\n","const trim = (source: string) => source.trim()\n\nexport { trim }\n","import { curry } from 'utils'\n\nconst startsWith = curry((what: string, where: string) => where.indexOf(what) === 0)\n\nexport { startsWith }\n","import { exec, replace } from 'utils'\n\nimport { INodeBlockquote, INodeParagraph, IParsed, ITokenizer } from 'models'\n\nconst execBlockquote =\n  exec(/^( *>[^\\n]+(\\n(?! *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$))[^\\n]+)*\\n*)+/)\nconst clearBlockquote = replace(/^ *> ?/gm, '')\nconst captureBlockquote = (source: string, tokenize: ITokenizer): IParsed<INodeBlockquote> | null => {\n  if (source[0] !== '>') {\n    return null\n  }\n\n  const result = execBlockquote(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  let children = tokenize(clearBlockquote(capture))\n\n  if (children.length === 1 && children[0].type === 'paragraph') {\n    children = (children[0] as INodeParagraph).children\n  }\n\n  return {\n    token: {\n      type: 'blockquote',\n      children: tokenize(clearBlockquote(capture))\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureBlockquote }\n","import { exec, replace } from 'utils'\n\nimport { INodeCodeBlock, IParsed } from 'models'\n\nconst execCodeNormal = exec(/^( {4}[^\\n]+\\n*)+/)\nconst clearCode = replace(/^ {4}/gm, '')\nconst execCodeFence = exec(/^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\s*\\1 *(?:\\n+|$)/)\n\nconst captureCodeNormal = (source: string): IParsed<INodeCodeBlock> | null => {\n  if (source[0] !== '`') {\n    return null\n  }\n\n  const result = execCodeNormal(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'codeblock',\n      language: '',\n      value: clearCode(capture)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nconst captureCodeFence = (source: string): IParsed<INodeCodeBlock> | null => {\n  const result = execCodeFence(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const language = result[2]\n  const value = result[3]\n\n  return {\n    token: {\n      type: 'codeblock',\n      language,\n      value\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nconst captureCodeBlock = (source: string): IParsed<INodeCodeBlock> | null =>\n  captureCodeNormal(source) || captureCodeFence(source)\nexport { captureCodeBlock }\n","import { exec } from 'utils'\n\nimport { INodeHeading, IParsed, ITokenizer } from 'models'\n\nconst execHeading = exec(/^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/)\nconst execLHeading = exec(/^([^\\n]+)\\n *([=-]){2,} *(?:\\n+|$)/)\nconst getLevel = (input: string): number => {\n  if (input[0] === '#') {\n    return input.length\n  }\n\n  return input[0] === '=' ? 1 : 2\n}\n\nconst captureHeading = (source: string, _: any, inlineLexer: ITokenizer): IParsed<INodeHeading> | null => {\n  const isNormal = source[0] === '#'\n  const result = (isNormal && execHeading(source)) || execLHeading(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const level = isNormal ? result[1] : result[2]\n  const rawValue = isNormal ? result[2] : result[1]\n\n  return {\n    token: {\n      type: 'heading',\n      level: getLevel(level),\n      children: inlineLexer(rawValue)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureHeading }\n","import { exec } from 'utils'\n\nimport { INodeHR, IParsed } from 'models'\n\nconst execHR = exec(/^ *(?:\\*{3,}|-{3,}|_{3,}) *(?:\\n+|$)/)\n\nconst captureHR = (source: string): IParsed<INodeHR> | null => {\n  const result = execHR(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: { type: 'hr' },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureHR }\n","import { exec } from 'utils'\n\nimport { INodeHTML, IParsed } from 'models'\n\nconst execHTML = exec(/^(?:<!--[\\s\\S]*?--> *(?:\\n|\\s*$)|<((?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:\\/|[^\\w\\s@]*@)\\b)[\\s\\S]+?<\\/\\1> *(?:\\n{2,}|\\s*$)|<(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:\\/|[^\\w\\s@]*@)\\b(?:\"[^\"]*\"|'[^']*'|[^'\">])*?> *(?:\\n{2,}|\\s*$))/) // tslint:disable-line max-line-length\n\nconst captureHTML = (source: string): IParsed<INodeHTML> | null => {\n  if (source[0] !== '<') {\n    return null\n  }\n\n  const result = execHTML(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'html',\n      value: capture\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureHTML }\n","import { compose, exec, match, replace } from 'utils'\n\nimport { INodeList, INodeListItem, INodeParagraph, IParsed, ITokenizer } from 'models'\n\nconst execList = exec(/^( *)((?:[*+-]|\\d+\\.)) [\\s\\S]+?(?:\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))|\\n+(?= *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$))|\\n{2,}(?! )(?!\\1(?:[*+-]|\\d+\\.) )\\n*|\\s*$)/) // tslint:disable-line max-line-length\nconst matchItems = match(/^( *)((?:[*+-]|\\d+\\.)) [^\\n]*(?:\\n(?!\\1(?:[*+-]|\\d+\\.) )[^\\n]*)*/gm)\nconst removeBullets = replace(/^ *([*+-]|\\d+\\.) +/, '')\nconst removeSpaces = replace(/^ */gm, '')\nconst matchBullet = match(/^(\\d)/)\nconst precedeList = replace(/\\n(?=\\d*\\. )/, '\\n\\n')\n\nconst captureList = (source: string, tokenize: ITokenizer): IParsed<INodeList> | null => {\n  const result = execList(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const bull = result[2]\n\n  const parseChild = compose(tokenize, precedeList, removeSpaces, removeBullets)\n  const topItemsParsed = matchItems(capture).map((item): INodeListItem => {\n    let itemChildren = parseChild(item)\n\n    if (itemChildren.length === 1 && itemChildren[0].type === 'paragraph') {\n      itemChildren = (itemChildren[0] as INodeParagraph).children\n    }\n\n    return {\n      type: 'listitem',\n      children: itemChildren\n    }\n  })\n\n  const startToken = matchBullet(bull)\n  const token: INodeList = {\n    type: 'list',\n    ordered: !!startToken,\n    start: startToken && +startToken[1],\n    children: topItemsParsed\n  }\n\n  return {\n    token,\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureList }\n","import { exec } from 'utils'\n\nimport { INodeSpace, IParsed } from 'models'\n\nconst execNewLine = exec(/^\\n+/)\n\nconst captureNewLine = (source: string): IParsed<INodeSpace> | null => {\n  const result = execNewLine(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: { type: 'space' },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureNewLine }\n","import { exec, replace } from 'utils'\n\nimport { INodeParagraph, IParsed, ITokenizer } from 'models'\n\nconst execParagraph = exec(/^((?:[^\\n]+\\n?)+)\\n*/)\nconst removeLastLineBreak = replace(/\\n$/, ' ')\n\nconst captureParagraph = (source: string, _: any, inlineLexer: ITokenizer): IParsed<INodeParagraph> | null => {\n  const result = execParagraph(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const rawValue = result[1]\n\n  return {\n    token: {\n      type: 'paragraph',\n      children: inlineLexer(removeLastLineBreak(rawValue))\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureParagraph }\n","import { compose, exec, map, matches, replace, split, trim } from 'utils'\n\nimport { INodeItem, INodeTable, IParsed, ITokenizer } from 'models'\n\nconst rowSep = / *\\| */\nconst removeHeaderBounds = replace(/^ *| *\\| *$/g, '')\nconst removeCellBounds = replace(/^ *\\| *| *\\| *$/g, '')\nconst removeRowBounds = replace(/^ *|\\| *$/g, '')\nconst removeLastLineBreak = replace(/\\n$/, ' ')\nconst removeLastBounds = replace(/(?: *\\| *)?\\n$/, '')\nconst splitByLineBreak = split('\\n')\nconst isRight = matches(/^ *-+: *$/)\nconst isCenter = matches(/^ *:-+: *$/)\n\nconst splitRow = (input: string) => {\n  const result: string[] = []\n  let cell = 0\n\n  for (let i = 0; i < input.length; i += 1) {\n    if (input[i] === '|' && input[i - 1] !== '`' && input[i - 1] !== '\\\\') {\n      cell++\n      continue\n    }\n    result[cell] = (result[cell] || '') + input[i]\n  }\n\n  return map(trim, result)\n}\n\nconst getTableHeader = (lexer: ITokenizer, source: string): INodeItem[][] =>\n  compose(map(lexer), splitRow, removeHeaderBounds)(source)\nconst getTableRow = compose(splitRow, removeCellBounds)\nconst getCellAlign = (input: string): string | null => {\n  if (isRight(input)) {\n    return 'right'\n  } else if (isCenter(input)) {\n    return 'center'\n  } else {\n    return 'left'\n  }\n}\nconst getTableAlign = compose(map(getCellAlign), split(rowSep), removeRowBounds)\nconst getNormalCells = (lexer: ITokenizer, cells: string): INodeItem[][][] =>\n  compose(map(compose(map(lexer), getTableRow)), splitByLineBreak, removeLastBounds)(cells)\nconst getNPCells = (lexer: ITokenizer, cells: string): INodeItem[][][] =>\n  compose(map(compose(map(lexer), split(rowSep))), splitByLineBreak, removeLastLineBreak)(cells)\n\nconst execNPTable = exec(/^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/)\nconst execTableNormal = exec(/^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/)\n\nconst captureTable = (source: string, _: any, inlineLexer: ITokenizer): IParsed<INodeTable> | null => {\n  let result = execNPTable(source)\n  let isNP = true\n\n  if (!result) {\n    result = execTableNormal(source)\n    isNP = false\n  }\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const header = result[1]\n  const align = result[2]\n  const cells = result[3]\n\n  if (!capture) {\n    return null\n  }\n\n  return {\n    token: {\n      type: 'table',\n      header: getTableHeader(inlineLexer, header),\n      align: getTableAlign(align),\n      cells: isNP ? getNPCells(inlineLexer, cells) : getNormalCells(inlineLexer, cells)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureTable }\n","import { exec } from 'utils'\n\nimport { INodeCode, IParsed } from 'models'\n\nconst execCode = exec(/^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/)\nconst captureCode = (source: string): IParsed<INodeCode> | null => {\n  if (source[0] !== '`') {\n    return null\n  }\n\n  const result = execCode(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const code = result[2]\n\n  return {\n    token: {\n      type: 'code',\n      value: code\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureCode }\n","import { exec } from 'utils'\n\nimport { INodeEm, IParsed, ITokenizer } from 'models'\n\nconst execEm = exec(/^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/)\nconst captureEm = (source: string, inlineLexer: ITokenizer): IParsed<INodeEm> | null => {\n  if (source[0] !== '_' && source[0] !== '*') {\n    return null\n  }\n\n  const result = execEm(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const a = result[1]\n  const b = result[2]\n\n  return {\n    token: {\n      type: 'em',\n      children: inlineLexer(b || a)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureEm }\n","import { exec } from 'utils'\n\nimport { INodeText, IParsed } from 'models'\n\nconst execEscape = exec(/^\\\\([\\\\`*{}[\\]()#+\\-.!_>~|])/)\nconst captureEscape = (source: string): IParsed<INodeText> | null => {\n  if (source[0] !== '\\\\') {\n    return null\n  }\n\n  const result = execEscape(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'text',\n      value: capture\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureEscape }\n","import { exec } from 'utils'\n\nimport { INodeHTML, IParsed } from 'models'\n\nconst execInlineHTML = exec(/^(?:<(a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img))(?: *\\S+=['\"].*['\"])*(?: *\\/>|>.*?<\\/\\1>)/) // tslint:disable-line max-line-length\n\nconst captureInlineHTML = (source: string): IParsed<INodeHTML> | null => {\n  if (source[0] !== '<') {\n    return null\n  }\n\n  const result = execInlineHTML(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'html',\n      value: capture\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureInlineHTML }\n","import { exec } from 'utils'\n\nimport { INodeLineBreak, IParsed } from 'models'\n\nconst execLineBreak = exec(/^ *\\n(?!\\s*$)/)\nconst captureLineBreak = (source: string): IParsed<INodeLineBreak> | null => {\n  const result = execLineBreak(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'br'\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureLineBreak }\n","import { exec, matches } from 'utils'\n\nimport { INodeImage, INodeLink, IParsed, ITokenizer } from 'models'\n\nconst execAutolink = exec(/^<([^ >]+(@|:\\/)[^ >]+)>/)\nconst captureAutolink = (source: string): IParsed<INodeLink> | null => {\n  if (source[0] !== '<') {\n    return null\n  }\n\n  const result = execAutolink(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const at = result[2]\n  let text = result[1]\n  let href = ''\n\n  if (at === '@') {\n    text = text.charAt(6) === ':' ? text.substring(7) : text\n    href = 'mailto:' + text\n  } else {\n    href = text\n  }\n\n  return {\n    token: {\n      type: 'link',\n      href,\n      children: [\n        {\n          type: 'text',\n          value: text\n        }\n      ]\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nconst testUrlStart = matches(/^http/)\nconst execUrl = exec(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')}\\]\\s])/)\nconst captureUrl = (source: string): IParsed<INodeLink> | null => {\n  if (!testUrlStart(source)) {\n    return null\n  }\n\n  const result = execUrl(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const text = result[1]\n\n  return {\n    token: {\n      type: 'link',\n      href: text,\n      children: [\n        {\n          type: 'text',\n          value: text\n        }\n      ]\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nconst execLink = exec(/^!?\\[(.*)\\]\\((?:([\\S]*) *[\"'](.*)[\"']\\)|(.*)(?: *\\)))/)\nconst fixLink = (input: string) => {\n  let parenLevel = 0\n  let result = ''\n  for (let i = 0; i < input.length; i += 1) {\n    if (input[i] === ')' && parenLevel === 0) {\n      break\n    }\n\n    if (input[i] === '(') {\n      parenLevel++\n    }\n\n    if (input[i] === ')') {\n      parenLevel--\n    }\n\n    result = result + input[i]\n  }\n\n  return [result, input.substring(result.length)]\n}\n\nconst captureLink = (source: string, inlineLexer: ITokenizer): IParsed<INodeLink | INodeImage> | null => {\n  if (source[0] !== '[' && source[0] !== '!') {\n    return null\n  }\n\n  const result = execLink(source)\n  let token: INodeLink | INodeImage\n  if (!result) {\n    return null\n  }\n\n  let capture = result[0]\n  const text = result[1]\n  let href = result[2]\n  const title = result[3]\n\n  if (result[4]) {\n    const fixedLink = fixLink(result[4])\n    href = fixedLink[0]\n    capture = fixedLink[1].length ? capture.slice(0, -fixedLink[1].length) : capture\n  }\n\n  if (capture[0] === '!') {\n    token = {\n      type: 'image',\n      src: href,\n      alt: text\n    }\n  } else {\n    token = {\n      type: 'link',\n      href,\n      children: inlineLexer(text)\n    }\n  }\n\n  if (title) {\n    token.title = title\n  }\n\n  return {\n    token,\n    newSource: source.substring(capture.length)\n  }\n}\nconst captureLinks = (source: string, inlineLexer: ITokenizer): IParsed<INodeLink | INodeImage> | null =>\n  captureAutolink(source) || captureUrl(source) || captureLink(source, inlineLexer)\n\nexport { captureLinks }\n","import { exec } from 'utils'\n\nimport { INodeStrikethrough, IParsed, ITokenizer } from 'models'\n\nconst execStrikethrough = exec(/^~~(?=\\S)([\\s\\S]*?\\S)~~/)\nconst captureStrikethrough = (source: string, inlineLexer: ITokenizer): IParsed<INodeStrikethrough> | null => {\n  if (source[0] !== '~') {\n    return null\n  }\n\n  const result = execStrikethrough(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const rawValue = result[1]\n\n  return {\n    token: {\n      type: 'strikethrough',\n      children: inlineLexer(rawValue)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureStrikethrough }\n","import { exec } from 'utils'\n\nimport { INodeStrong, IParsed, ITokenizer } from 'models'\n\nconst execStrong = exec(/^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/)\nconst captureStrong = (source: string, inlineLexer: ITokenizer): IParsed<INodeStrong> | null => {\n  if (source[0] !== '_' && source[0] !== '*') {\n    return null\n  }\n\n  const result = execStrong(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n  const a = result[1]\n  const b = result[2]\n\n  return {\n    token: {\n      type: 'strong',\n      children: inlineLexer(b || a)\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureStrong }\n","import { exec } from 'utils'\n\nimport { INodeText, IParsed } from 'models'\n\nconst execText = exec(/^[\\s\\S]+?(?=[\\\\<![_*`~]|https?:\\/\\/| *\\n|$)/)\n\nconst captureText = (source: string): IParsed<INodeText> | null => {\n  const result = execText(source)\n\n  if (!result) {\n    return null\n  }\n\n  const capture = result[0]\n\n  return {\n    token: {\n      type: 'text',\n      value: capture\n    },\n    newSource: source.substring(capture.length)\n  }\n}\n\nexport { captureText }\n","import {\n  captureBlockquote,\n  captureCodeBlock,\n  captureHeading,\n  captureHR,\n  captureHTML,\n  captureList,\n  captureNewLine,\n  captureParagraph,\n  captureTable\n} from 'blockParsers'\nimport { clearSource } from 'utils'\n\nimport {\n  captureCode,\n  captureEm,\n  captureEscape,\n  captureInlineHTML,\n  captureLineBreak,\n  captureLinks,\n  captureStrikethrough,\n  captureStrong,\n  captureText\n} from 'inlineParsers'\n\nimport { IMDJOptions, INodeItem, IParsed, IParser, ITokenizer } from 'models'\n\ntype IParsersList = Array<{ parser: IParser, priority: number }>\n\nconst defaultOptions: IMDJOptions = {\n  html: false\n}\n\nconst MDJ = (_options?: IMDJOptions) => {\n  const options = Object.assign({}, defaultOptions, _options)\n  const parsers: {\n    block: IParsersList\n    inline: IParsersList\n  } = {\n    block: [\n      { parser: captureNewLine, priority: 1000 },\n      { parser: captureHeading, priority: 900 },\n      { parser: captureHR, priority: 800 },\n      { parser: captureBlockquote, priority: 700 },\n      { parser: captureCodeBlock, priority: 600 },\n      { parser: captureTable, priority: 500 },\n      { parser: captureList, priority: 400 },\n      { parser: captureParagraph, priority: 0 }\n    ],\n    inline: [\n      { parser: captureEscape, priority: 1000 },\n      { parser: captureCode, priority: 900 },\n      { parser: captureStrong, priority: 800 },\n      { parser: captureEm, priority: 700 },\n      { parser: captureStrikethrough, priority: 600 },\n      { parser: captureLinks, priority: 500 },\n      { parser: captureLineBreak, priority: 400 },\n      { parser: captureText, priority: 0 }\n    ]\n  }\n\n  if (options.html) {\n    addParser('block', captureHTML, 200)\n    addParser('inline', captureInlineHTML, 200)\n  }\n\n  const blockLexer: ITokenizer = lexer('block')\n  const inlineLexer: ITokenizer = lexer('inline')\n\n  function addParser (type: 'block' | 'inline', parser: IParser, priority: number) {\n    parsers[type].push({ parser, priority })\n    parsers[type] = parsers[type].sort((a, b) => b.priority - a.priority)\n  }\n\n  function pinchToken (type: 'block' | 'inline', source: string): IParsed<INodeItem> | null {\n    const l = parsers[type].length\n    let token\n    let newSource = ''\n\n    for (let i = 0; i < l; i += 1) {\n      const parser = parsers[type][i].parser\n      const parsed = type === 'block' ?\n        parser(source, blockLexer, inlineLexer) :\n        parser(source, inlineLexer)\n\n      if (parsed) {\n        newSource = parsed.newSource\n        token = parsed.token\n        break\n      }\n    }\n\n    if (!token) {\n      return null\n    }\n\n    return {\n      token,\n      newSource\n    }\n  }\n\n  function lexer (type: 'block' | 'inline') {\n    return (source: string): INodeItem[] => {\n      const tokens: INodeItem[] = []\n\n      while (source.length > 0) {\n        const { token = null, newSource = '' } = pinchToken(type, source) || {}\n\n        if (source === newSource || !token) {\n          throw new Error('Infinite loop on byte: ' + source.charCodeAt(0))\n        }\n\n        tokens.push(token)\n        source = newSource\n      }\n\n      return tokens\n    }\n  }\n\n  function prepareSource (source: string) {\n    return clearSource(source)\n  }\n\n  const parser = {\n    parse: function parse (source: string) {\n      return blockLexer(prepareSource(source))\n    },\n    useInlineParser: function useInlineParser (parserFunc: IParser, priority: number) {\n      addParser('inline', parserFunc, priority)\n      return parser\n    },\n    useBlockParser: function useBlockParser (parserFunc: IParser, priority: number) {\n      addParser('block', parserFunc, priority)\n      return parser\n    }\n  }\n\n  return parser\n}\n\nexport { MDJ }\n","import { MDJ } from 'core/MDJ'\n\nconst parse = (source: string) => MDJ()\n  .parse(source)\n\nexport default MDJ\nexport { parse }\n"],"names":["curry","fn","arguments","length","inner","args","Array","prototype","slice","call","apply","bind","concat","clearSource","input","replace","compose","fns","l","arg","result","i","exec","a","b","regExp","map","match","matches","withWhat","what","test","from","to","split","trim","where","indexOf","source","execBlockquote","clearBlockquote","captureBlockquote","tokenize","capture","children","type","token","newSource","substring","execCodeNormal","clearCode","execCodeFence","captureCodeNormal","language","value","captureCodeFence","captureCodeBlock","execHeading","execLHeading","getLevel","captureHeading","_","inlineLexer","isNormal","level","rawValue","execHR","captureHR","execHTML","captureHTML","execList","matchItems","removeBullets","removeSpaces","matchBullet","precedeList","captureList","bull","parseChild","topItemsParsed","item","itemChildren","startToken","ordered","start","execNewLine","captureNewLine","execParagraph","removeLastLineBreak","captureParagraph","rowSep","removeHeaderBounds","removeCellBounds","removeRowBounds","removeLastBounds","splitByLineBreak","isRight","isCenter","splitRow","cell","getTableHeader","lexer","getTableRow","getCellAlign","getTableAlign","getNormalCells","cells","getNPCells","execNPTable","execTableNormal","captureTable","isNP","header","align","execCode","captureCode","execEm","captureEm","execEscape","captureEscape","execInlineHTML","captureInlineHTML","execLineBreak","captureLineBreak","execAutolink","captureAutolink","at","text","href","charAt","testUrlStart","execUrl","captureUrl","execLink","fixLink","parenLevel","captureLink","title","fixedLink","src","alt","captureLinks","execStrikethrough","captureStrikethrough","execStrong","captureStrong","execText","captureText","defaultOptions","html","MDJ","_options","parser","priority","parsers","push","sort","parser_1","parsed","blockLexer","tokens","_a","_b","_c","Error","charCodeAt","options","Object","assign","block","inline","addParser","parse","prepareSource","useInlineParser","parserFunc","useBlockParser"],"mappings":"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"}